(in-package goal)

(defbehavior target-hl-attacked target ((arg0 symbol) (arg1 attack-info) (arg2 process) (arg3 touching-shapes-entry) (arg4 (state symbol attack-info target)))
  (when (not (logtest? (-> self state-flags) (state-flags being-attacked)))
    (cond
      ((or (logtest? (-> self state-flags) (state-flags invulnerable timed-invulnerable invuln-powerup))
           (and (logtest? (-> arg1 mask) (attack-mask mode))
                (= (-> arg1 mode) 'darkeco)
                (and (and (= (-> self fact eco-type) (pickup-type eco-red)) (>= (-> self fact eco-level) 1.0))
                     (logtest? (state-flags dangerous flop-hit-ground) (-> self state-flags)))))
       (case arg0
         (('attack-or-shove))
         (('attack-invinc) (set! arg0 'attack))
         (else (return #f))))
      (else
       (case arg0
         (('attack-or-shove 'attack-invinc) (set! arg0 'attack)))))
    (mem-copy! (the-as pointer (-> self attack-info-rec)) (the-as pointer arg1) 104)
    (when arg3
      (let ((a1-2 (prims-touching? arg3 (-> self control) (the-as uint -1))))
        (when a1-2
          (get-intersect-point (-> self attack-info-rec intersection) a1-2 (-> self control) arg3)
          (logior! (-> self attack-info-rec mask) (attack-mask intersection)))))
    (set! (-> self attack-info-rec prev-state) (-> self state))
    (logior! (-> self attack-info-rec mask) (attack-mask atki13))
    (when (not (logtest? (-> self attack-info-rec mask) (attack-mask attacker)))
      (set! (-> self attack-info-rec attacker) (process->handle arg2))
      (logior! (-> self attack-info-rec mask) (attack-mask attacker)))
    (cond
      ((and (logtest? (-> self attack-info-rec mask) (attack-mask mode))
            (and (= (-> self attack-info-rec mode) 'damage) (not (and (= (-> self game mode) 'play) (>= 1.0 (-> self fact health))))))
       (pickup-collectable! (-> self fact) (pickup-type eco-green) (- (-> *FACT-bank* health-single-inc)) (the-as handle #f))
       (process-spawn part-tracker
                      :init
                      part-tracker-init
                      (-> *part-group-id-table* 1)
                      -1
                      #f
                      #f
                      #f
                      (if (logtest? (-> self attack-info-rec mask) (attack-mask intersection))
                        (-> self attack-info-rec intersection)
                        (-> self control root-prim prim-core))
                      :to
                      self)
       (target-timed-invulnerable (if (logtest? (-> self attack-info-rec mask) (attack-mask invinc-time))
                                    (-> self attack-info-rec invinc-time)
                                    (-> *TARGET-bank* hit-invulnerable-timeout))
                                  self)
       (cpad-set-buzz! (-> *cpad-list* cpads 0) 0 255 (seconds 0.5))
       (sound-play "oof")
       #t)
      (else
       (logior! (-> self state-flags) (state-flags being-attacked))
       (if (and (= (-> self game mode) 'play) (and (>= 1.0 (-> self fact health)) (= arg0 'attack)))
         (logior! (-> self state-flags) (state-flags dying)))
       ;;(go arg4 arg0 (-> self attack-info-rec))
 
       ))
               (print "ATTACKED")  
       ))

(defbehavior target-hl-generic-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (local-vars (v0-0 object))
  (case arg2
    (('get-pickup)
     (when (not (logtest? (-> self state-flags) (state-flags dying)))
       (let ((s4-0 (-> arg3 param 0))
             (f28-0 (the-as float (-> arg3 param 1))))
         (if (!= (pickup-collectable! (-> self fact) (the-as pickup-type s4-0) (the-as float 0.0) (the-as handle #f))
                 (pickup-collectable! (-> self fact) (the-as pickup-type s4-0) f28-0 (process->handle arg0)))
           #t
           'full))))
    (('reset-pickup) (reset! (-> self fact) (the-as symbol (-> arg3 param 0))))
    (('reset-collide)
     (cond
       ((-> self control unknown-symbol00)
        (target-collide-set! (-> self control unknown-symbol00) (-> self control unknown-float90)))
       ((-> self control unknown-symbol30) (target-danger-set! (-> self control unknown-symbol30) #f))))
    (('level-deactivate) #f)
    (('level-enter)
     (let ((v1-21 (level-get *level* (the-as symbol (-> arg3 param 0)))))
       (when v1-21
         (let ((s5-1 (-> v1-21 info)))
           (let ((v1-22 (-> s5-1 buzzer)))
             (if (zero? v1-22)
               (set! (-> self fact buzzer) 0.0)
               (set! (-> self fact buzzer)
                     (pickup-collectable! (-> self fact) (pickup-type buzzer) (the float (logior -65536 v1-22)) (the-as handle #f)))))
           (if (and (zero? (-> *game-info* enter-level-time (-> s5-1 index))) (>= (-> *level-task-data-remap* length) (-> s5-1 index)))
             (set-time! (-> *game-info* enter-level-time (-> *level-task-data-remap* (+ (-> s5-1 index) -1))))))
         (send-event (ppointer->process (-> *hud-parts* buzzers)) 'sync)
         (format #t "GAMEPLAY: enter ~A~%" (-> arg3 param 0)))))
    (('get-attack-count)
     (set! v0-0 (+ (-> self control unknown-dword51) (-> arg3 param 0)))
     (set! (-> self control unknown-dword51) (the-as int v0-0))
     v0-0)
    (('continue) (go target-continue (the-as continue-point (-> arg3 param 0))))
    (('query)
     (case (-> arg3 param 0)
       (('powerup) (and (= (-> self fact eco-type) (-> arg3 param 1)) (< 0.0 (-> self fact eco-level))))
       (('pickup)
        (pickup-collectable! (-> self fact) (the-as pickup-type (-> arg3 param 1)) (the-as float 0.0) (the-as handle #f)))
       (('ground-height) (target-height-above-ground))))
    (('trans)
     (case (-> arg3 param 0)
       (('save)
        (set! (-> self alt-cam-pos quad) (-> self control trans quad))
        (logior! (-> self state-flags) (state-flags has-saved-position))
        (mem-copy! (the-as pointer (-> arg3 param 1)) (the-as pointer (-> self control trans)) 48))
       (('restore)
        (logclear! (-> self state-flags) (state-flags has-saved-position))
        (let ((gp-1 (-> arg3 param 1)))
          (move-to-point! (-> self control) (the-as vector (+ gp-1 0)))
          (quaternion-copy! (-> self control quat) (the-as quaternion (+ gp-1 16))))
        (rot->dir-targ! (-> self control))
        (logior! (-> self control status) (cshape-moving-flags onsurf onground tsurf))
        (set! v0-0 (current-time))
        (set! (-> self control last-ground-time) (the-as time-frame v0-0))
        v0-0)
       (('reset)
        (set! v0-0 (logclear (-> self state-flags) (state-flags has-saved-position)))
        (set! (-> self state-flags) (the-as state-flags v0-0))
        v0-0)))
    (('effect) (target-powerup-effect (the-as symbol (-> arg3 param 0))))
    (('do-effect)
     (effect-control-method-10 (-> self skel effect) (the-as symbol (-> arg3 param 0)) (the-as float (-> arg3 param 1)) -1)
     (if (-> self sidekick)
       (effect-control-method-10 (-> self sidekick 0 skel effect)
                                 (the-as symbol (-> arg3 param 0))
                                 (the-as float (-> arg3 param 1))
                                 -1)))
    (('neck)
     (set! (-> self neck flex-blend) (the-as float (-> arg3 param 0)))
     (cond
       ((-> arg3 param 1)
        (logior! (-> self state-flags) (state-flags looking-at-enemy))
        (set! (-> self alt-neck-pos quad) (-> (the-as vector (-> arg3 param 1)) quad))
        (look-at-enemy! (-> self neck) (-> self alt-neck-pos) 'force arg0))
       (else
        (set! v0-0 (logclear (-> self state-flags) (state-flags looking-at-enemy)))
        (set! (-> self state-flags) (the-as state-flags v0-0))
        v0-0)))
    (('sidekick)
     (cond
       ((and (-> arg3 param 0) (not (-> self sidekick)))
        (let ((gp-2 (get-process *default-dead-pool* sidekick #x4000)))
          (set! v0-0
                (when gp-2
                  (let ((t9-21 (method-of-type sidekick activate)))
                    (t9-21 (the-as sidekick gp-2) self 'sidekick (the-as pointer #x70004000)))
                  (run-now-in-process gp-2 init-sidekick)
                  (-> gp-2 ppointer))))
        (set! (-> self sidekick) (the-as (pointer sidekick) v0-0))
        v0-0)
       ((and (not (-> arg3 param 0)) (-> self sidekick))
        (deactivate (-> self sidekick 0))
        (set! (-> self sidekick) (the-as (pointer sidekick) #f))
        #f)))
    (('blend-shape)
     (if (-> arg3 param 0)
       (logior! (-> self skel status) (janim-status blerc))
       (logclear! (-> self skel status) (janim-status blerc)))
     (let ((v1-105 (new 'stack-no-clear 'event-message-block)))
       (set! (-> v1-105 from) arg0)
       (set! (-> v1-105 num-params) arg1)
       (set! (-> v1-105 message) arg2)
       (set! (-> v1-105 param 0) (-> arg3 param 0))
       (set! (-> v1-105 param 1) (-> arg3 param 1))
       (set! (-> v1-105 param 2) (-> arg3 param 2))
       (set! (-> v1-105 param 3) (-> arg3 param 3))
       (set! (-> v1-105 param 4) (-> arg3 param 4))
       (set! (-> v1-105 param 5) (-> arg3 param 5))
       (set! (-> v1-105 param 6) (-> arg3 param 6))
       (send-event-function (ppointer->process (-> self sidekick)) v1-105)))
    (('shadow)
     (cond
       ((-> arg3 param 0)
        (let ((v1-108 (-> self draw shadow-ctrl))) (logclear! (-> v1-108 settings flags) (shadow-flags disable-draw)))
        0)
       (else (let ((v1-110 (-> self draw shadow-ctrl))) (logior! (-> v1-110 settings flags) (shadow-flags disable-draw))) 0)))
    (('rotate-y-angle)
     (quaternion-rotate-y! (-> self control quat-targ)
                           (-> self control quat-targ)
                           (the-as float (-> arg3 param 0)))
     (if (= (-> *cpad-list* cpads (-> self control cpad number) stick0-speed) 0.0)
       (rot->dir-targ! (-> self control))))
    (('touched) (send-event arg0 'touch (-> arg3 param 0)))
    (('dry) (set! (-> self water drip-wetness) 0.0))
    (('reset-height) (set! (-> self control last-air-trans quad) (-> self control trans quad)) #f)
    (('draw)
     (if (-> arg3 param 0)
       (logclear! (-> self draw status) (draw-status skip-bones))
       (logior! (-> self draw status) (draw-status skip-bones)))
     (let ((v1-132 (new 'stack-no-clear 'event-message-block)))
       (set! (-> v1-132 from) arg0)
       (set! (-> v1-132 num-params) arg1)
       (set! (-> v1-132 message) arg2)
       (set! (-> v1-132 param 0) (-> arg3 param 0))
       (set! (-> v1-132 param 1) (-> arg3 param 1))
       (set! (-> v1-132 param 2) (-> arg3 param 2))
       (set! (-> v1-132 param 3) (-> arg3 param 3))
       (set! (-> v1-132 param 4) (-> arg3 param 4))
       (set! (-> v1-132 param 5) (-> arg3 param 5))
       (set! (-> v1-132 param 6) (-> arg3 param 6))
       (send-event-function (ppointer->process (-> self manipy)) v1-132)))
    (('no-load-wait)
     (set! v0-0 (+ (current-time) (the-as time-frame (-> arg3 param 0))))
     (set! (-> self no-load-wait) (the-as time-frame v0-0))
     v0-0)
    (('no-look-around)
     (set! (-> self no-look-around-wait) (+ (current-time) (the-as time-frame (-> arg3 param 0))))
     (if (= (-> self next-state name) 'target-look-around) (send-event self 'end-mode)))
    (('change-state)
     (go (the-as (state object object object object target) (-> arg3 param 0))
         (-> arg3 param 1)
         (-> arg3 param 2)
         (-> arg3 param 3)
         (-> arg3 param 4)))))

(defbehavior target-hl-standard-event-handler target ((arg0 process) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('attack 'attack-or-shove 'attack-invinc)
     (target-hl-attacked arg2
                      (the-as attack-info (-> arg3 param 1))
                      arg0
                      (the-as touching-shapes-entry (-> arg3 param 0))
                      target-hit))
    (('shove)
     (when (!= (-> self next-state name) 'target-hit)
       (mem-copy! (the-as pointer (-> self attack-info-rec)) (the-as pointer (-> arg3 param 1)) 104)
       (when (not (logtest? (-> self attack-info-rec mask) (attack-mask attacker)))
         (set! (-> self attack-info-rec attacker) (process->handle arg0))
         (logior! (-> self attack-info-rec mask) (attack-mask attacker)))
       (go target-hit 'shove (-> self attack-info-rec))))
    (('launch) (mem-copy! (&-> (-> self control) unknown-pointer00) (the-as pointer arg3) 72) #t)
    (('loading)
     (if (not (or (and (logtest? (-> self control cur-surf flags) (surface-flags jump))
                       (not (logtest? (-> self control status) (cshape-moving-flags onsurf))))
                  (or (logtest? (-> self water flags) (water-flags wt09))
                      (logtest? (-> self state-flags) (state-flags dangerous sf02 being-attacked grabbed first-person-mode dying))
                      (logtest? (-> self control root-prim prim-core action)
                                (collide-action edgegrab-cam swingpole-active racer snowball tube flut))
                      (>= (-> self no-load-wait) (current-time)))))
       (go target-load-wait)))
    (('change-mode)
     (case (-> arg3 param 0)
       (('grab) (go target-grab))
       (('look-around) (go target-look-around))
       (('billy) (go target-billy-game))
       (('falling) (go target-falling #f))
       (('racing) (go target-racing-start (process->handle (the-as process (-> arg3 param 1)))))
       (('flut) (go target-flut-start (process->handle (the-as process (-> arg3 param 1)))))
       (('snowball) (go target-snowball-start (process->handle (the-as process (-> arg3 param 1)))))
       (('tube)
        (if (and (logtest? (-> self control status) (cshape-moving-flags onsurf))
                 (not (logtest? (-> self water flags) (water-flags wt09))))
          (go target-tube-start (process->handle (the-as process (-> arg3 param 1))))))
       (('periscope)
        (if (logtest? (-> self control status) (cshape-moving-flags onsurf))
          (go target-periscope (process->handle (the-as process (-> arg3 param 1))))))
       (('fishing) (go target-fishing (process->handle (the-as process (-> arg3 param 1)))))
       (('final-door)
        (go target-final-door
            (the-as basic (process->handle (the-as process (-> arg3 param 1))))
            (process->handle (the-as process (-> arg3 param 2)))))))
    (('play-anim) (go target-play-anim (the-as string (-> arg3 param 0)) (the-as handle arg1)))
    (('clone-anim) (go target-clone-anim (process->handle (the-as process (-> arg3 param 0)))))
    (('tongue) (target-apply-tongue (the-as vector (-> arg3 param 0))))
    (else (target-hl-generic-event-handler arg0 arg1 arg2 arg3))
    ))
